#include<iostream>
/* 两部分内容 1、信号的保存 2、信号的递达处理 */
int main()
{
    /* 1、这个位图是存在于task_struct结构体当中 */
    /* 
    1、pending位图
    进程是使用位图进行保存，使用pending位图，发信号其实就是修改pending位图 
    a.比特位的位置，信号编号 b.比特位的内容，是否 收到了对应的信号
    
    2、block位图
    a.比特位的位置，信号编号 b.比特位的内容，是否 阻塞了对应的信号
    要先检测是不是被阻塞了，要是没有被阻塞并且信号是产生的那么我们就递达该信号，这些事情使用这两个位图就可以完成

    3、handler表
    在内核之中除了这两个位图还存在一个函数指针数组，我猜测保存了信号动作，也就是信号抵达的所有方法
    a.这个数组的位置下标，就是信号的编号
    b.数组下标对应的内容，表示对应信号的处 理方法

    以上就是信号在内核之中信号的基本数据结构构成，普通信号只会被统计一次，剩下的就全部丢失了
    还有一种就叫做实时信号是维持一个队列
    */ 
   // 如果一个信号没有产生并不妨碍它可以先被阻塞

   /* 
    2、信号的捕捉流程 
    信号产生的时候信号是从内核态返回用户态的时候才进行处理的
    a. 用户态：自己写的代码是属于用户态的但是会访问两种资源
        1、操作系统的自身资源（getpid，waitpid）
        2、硬件资源（printf）
    b. 内核态：实际执行系统调用的是进程，但是身份其实是内核

    CPU之中两种寄存器
    1.可见寄存器
    2.不可见寄存器 
    但是无一例外都是和当前进程是强相关的，保存进程的上下文数据
 
    我是一个进程我怎么跑到OS之中去执行方法呢？ 
    之前提到的虚拟地址空间mm_struct和实际地址空间
    存在用户级别页表同时OS之中也维护着一张内核级别的页表
    每一个进程都有自己的地址空间（用户空间独占）内核空间（被映射到了每一个进程的3~4G）
    系统调用接口会帮你把你的用户权限从3号更改到0号状态

    现在我们可以明确信号的捕捉流程
    信号不会被立即处理而是在 “合适的时候” -> 从内核态返回用户态的时候进行处理
   */
   

    return 0;
}